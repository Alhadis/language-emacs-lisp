name: "Emacs Lisp"
scopeName: "source.emacs.lisp"
fileTypes: [
	"el"
	"elc"
	"spacemacs"
	"emacs"
	"emacs.desktop"
]
patterns: [include: "#main"]


repository:
	
	# Top-level patterns
	main:
		patterns: [
			{include: "#comment"}
			{include: "#lambda"}
			{include: "#definition"}
			{include: "#expression"}
			{include: "#operators"}
			{include: "#binding"}
			{include: "#keyword"}
			{include: "#string"}
			{include: "#number"}
			{include: "#quote"}
			{include: "#nil"}
		]
	
	
	# Binding
	binding:
		name: "storage.binding.emacs.lisp"
		match: "\\b(let|setq)\\b"
	
	
	# Comment-line
	comment:
		name: "comment.line.semicolon.emacs.lisp"
		begin: ";"
		end:   "$"
		beginCaptures:
			0: name: "punctuation.definition.comment.emacs.lisp"
		patterns: [include: "#modeline"]


	# def* statement
	definition:
		patterns: [{
			name: "meta.function.definition.emacs.lisp"
			begin: "(\\()(defun)(?!-)\\b(?:\\s*([-\\w]+))?"
			end:   "\\)"
			beginCaptures:
				1: name: "punctuation.section.expression.begin.emacs.lisp"
				2: name: "storage.type.function.emacs.lisp"
				3: name: "entity.function.name.emacs.lisp"
			endCaptures:
				0: name: "punctuation.section.expression.end.emacs.lisp"
			patterns: [include: "#defun-innards"]
		},{
			name: "storage.type.function.emacs.lisp"
			match: "\\b(?<!-)defun(?!-)\\b"
		},{
			name: "storage.type.$1.emacs.lisp"
			match: "\\b(?:(?:cl-)?def(advice|class|custom|face|group|package|struct|theme|type|var))\\b"
		},{
			name: "storage.type.$1.emacs.lisp"
			match: "\\b(define-(?:condition|widget))"
		}]
	
	
	"defun-innards":
		patterns: [{
			
			# Argument variables
			name: "meta.argument-list.expression.emacs.lisp"
			begin: "\\G\\s*(\\()"
			end:   "\\)"
			beginCaptures: 0: name: "punctuation.section.expression.begin.emacs.lisp"
			endCaptures:   0: name: "punctuation.section.expression.end.emacs.lisp"
			patterns: [
				name: "constant.language.$1.arguments.emacs.lisp"
				match: "&(optional|rest)(?=\\s|\\))"
				
				{name: "variable.parameter.emacs.lisp", match: "[-\\w]+"}
				{include: "$self"}
			]
			
		}, include: "$self"]


	# S-expression
	expression:
		patterns: [{
			name: "meta.expression.emacs.lisp"
			begin: "\\("
			end:   "\\)"
			beginCaptures: 0: name: "punctuation.section.expression.begin.emacs.lisp"
			endCaptures:   0: name: "punctuation.section.expression.end.emacs.lisp"
			patterns: [include: "$self"]
		},{
			name: "meta.quoted.expression.emacs.lisp"
			begin: "(\\')(\\()"
			end:   "\\)"
			beginCaptures:
				1: name: "punctuation.definition.symbol.emacs.lisp"
				2: name: "punctuation.section.quoted.expression.begin.emacs.lisp"
			endCaptures:
				0: name: "punctuation.section.quoted.expression.end.emacs.lisp"
			patterns: [include: "$self"]
		}]


	# :keywords
	keyword:
		name: "constant.keyword.emacs.lisp"
		match: "(:)[-\\w]+"
		captures:
			1: name: "punctuation.definition.keyword.emacs.lisp"


	# Lambda function
	lambda:
		name: "meta.lambda.expression.emacs.lisp"
		begin: "(\\()(lambda)\\s+"
		end:   "\\)"
		beginCaptures:
			1: name: "punctuation.section.expression.begin.emacs.lisp"
			2: name: "storage.type.lambda.function.emacs.lisp"
		endCaptures:
			0: name: "punctuation.section.expression.end.emacs.lisp"
		patterns: [include: "#defun-innards"]


	# Modeline
	modeline:
		name: "meta.modeline.emacs.lisp"
		match: "(-\\*-)(.*)(-\\*-)"
		captures:
			1: name: "punctuation.definition.modeline.begin.emacs.lisp"
			2: patterns: [include: "#modeline-innards"]
			3: name: "punctuation.definition.modeline.end.emacs.lisp"

	"modeline-innards":
		patterns: [{
			name: "meta.modeline.variable.emacs.lisp"
			match: "([^\\s:;]+)\\s*(:)\\s*([^;]*)"
			captures:
				1: name: "variable.assignment.modeline.emacs.lisp"
				2: name: "punctuation.separator.key-value.emacs.lisp"
				3: patterns: [include: "#modeline-innards"]
			}
			{name: "constant.boolean.emacs.lisp", match: "\\b(?<!-)t(?!-)\\b"}
			{name: "punctuation.terminator.statement.emacs.lisp", match: ";"}
			{name: "punctuation.separator.key-value.emacs.lisp",  match: ":"}
			{name: "string.other.modeline.emacs.lisp", match: "\\S+"}
		]


	# Empty value
	nil:
		name: "constant.language.nil.emacs.lisp"
		match: "\\bnil\\b"


	# Numeric literals
	number:
		patterns: [
			{name: "constant.numeric.float.emacs.lisp",   match: "(?<!\\w)-?\\d*\\.\\d+"}
			{name: "constant.numeric.integer.emacs.lisp", match: "(?<!\\w)-?\\d+"}
		]
		

	# Operators
	operators:
		patterns: [{
			name: "keyword.operator.emacs.lisp"
			match: "\\b(?<!-)(funcall)(?!-)\\b"
		},{
			name: "keyword.operator.numeric.emacs.lisp"
			match: "(?<=\\(|\\s|^)[-*+/](?=\\s|\\)|$)"
		}]


	# Argument-quoting
	quote:
		patterns: [{
			
			# (quote value)
			name: "keyword.control.quote.emacs.lisp"
			match: "\\bquote\\b"
		},{
			
			# 'value
			name: "string.quoted.other.emacs.lisp"
			match: "(')[-\\w]+"
			captures:
				1: name: "punctuation.definition.quote.emacs.lisp"
		}]

	
	# "Double-quoted" string
	string:
		name: "string.quoted.double.emacs.lisp"
		begin: '"'
		end:   '"'
		beginCaptures: 0: name: "punctuation.definition.string.begin.emacs.lisp"
		endCaptures:   0: name: "punctuation.definition.string.end.emacs.lisp"
		patterns: [
			match: '(\\\\).'
			name: "constant.character.escape.emacs.lisp"
			captures:
				1: name: "punctuation.escape.backslash.emacs.lisp"
		]
