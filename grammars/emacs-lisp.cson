name: "Emacs Lisp"
scopeName: "source.emacs.lisp"
fileTypes: [
	"el"
	"elc"
	"spacemacs"
	"emacs"
	"emacs.desktop"
]
patterns: [include: "#main"]


repository:
	
	# Top-level patterns
	main:
		patterns: [
			{include: "#comment"}
			{include: "#lambda"}
			{include: "#definition"}
			{include: "#expression"}
			{include: "#operators"}
			{include: "#functions"}
			{include: "#binding"}
			{include: "#keyword"}
			{include: "#string"}
			{include: "#number"}
			{include: "#quote"}
			{include: "#arg-values"}
			{include: "#boolean"}
		]
	
	
	# Special keywords used in function/macro definitions
	"arg-values":
		patterns: [{
			name: "constant.language.$1.arguments.emacs.lisp"
			match: "&(optional|rest)(?=\\s|\\))"
		}]
	
	
	# Binding
	binding:
		name: "storage.binding.emacs.lisp"
		match: "\\b(?<=[\\s()]|^)(let\\*?|set[fq]?)(?=[\\s()]|$)"
	

	# Boolean constants
	boolean:
		patterns: [
			{name: "constant.boolean.true.emacs.lisp", match: "\\b(?<=[\\s()]|^)t(?=[\\s()]|$)\\b"}
			{name: "constant.language.nil.emacs.lisp", match: "\\b(?<=[\\s()]|^)(nil)(?=[\\s()]|$)\\b"}
		]	
	
	
	# Comment-line
	comment:
		name: "comment.line.semicolon.emacs.lisp"
		begin: ";"
		end:   "$"
		beginCaptures:
			0: name: "punctuation.definition.comment.emacs.lisp"
		patterns: [include: "#modeline"]


	# def* statement
	definition:
		patterns: [{
			name: "meta.function.definition.emacs.lisp"
			begin: "(\\()(defun|defmacro|defsubst)(?!-)\\b(?:\\s*([-\\w]+))?"
			end:   "\\)"
			beginCaptures:
				1: name: "punctuation.section.expression.begin.emacs.lisp"
				2: name: "storage.type.$2.function.emacs.lisp"
				3: name: "entity.function.name.emacs.lisp"
			endCaptures:
				0: name: "punctuation.section.expression.end.emacs.lisp"
			patterns: [include: "#defun-innards"]
		},{
			name: "storage.type.function.emacs.lisp"
			match: "\\b(?<=[\\s()]|^)defun(?=[\\s()]|$)"
		},{
			name: "storage.type.$1.emacs.lisp"
			match: """(?x)(?<=[\\s()]|^)(?:
				(?:cl-)?def(advice|class|const|custom|face|image|group|package
				|struct|subst|theme|type|var))(?=[\\s()]|$)"""
		},{
			name: "storage.type.$1.emacs.lisp"
			match: "\\b(?<=[\\s()]|^)(define-(?:condition|widget))(?=[\\s()]|$)\\b"
		}]
	
	
	"defun-innards":
		patterns: [{
			
			# Argument variables
			name: "meta.argument-list.expression.emacs.lisp"
			begin: "\\G\\s*(\\()"
			end:   "\\)"
			beginCaptures: 0: name: "punctuation.section.expression.begin.emacs.lisp"
			endCaptures:   0: name: "punctuation.section.expression.end.emacs.lisp"
			patterns: [
				{include: "#arg-keywords"}
				{name: "variable.parameter.emacs.lisp", match: "[-\\w]+"}
				{include: "$self"}
			]
			
		}, include: "$self"]


	# S-expression
	expression:
		patterns: [{
			name: "meta.expression.emacs.lisp"
			begin: "\\("
			end:   "\\)"
			beginCaptures: 0: name: "punctuation.section.expression.begin.emacs.lisp"
			endCaptures:   0: name: "punctuation.section.expression.end.emacs.lisp"
			patterns: [include: "$self"]
		},{
			name: "meta.quoted.expression.emacs.lisp"
			begin: "(\\')(\\()"
			end:   "\\)"
			beginCaptures:
				1: name: "punctuation.definition.symbol.emacs.lisp"
				2: name: "punctuation.section.quoted.expression.begin.emacs.lisp"
			endCaptures:
				0: name: "punctuation.section.quoted.expression.end.emacs.lisp"
			patterns: [include: "$self"]
		}]


	# Primitives/Fundamental Lisp functions
	functions:
		name: "keyword.control.function.$1.emacs.lisp"
		match: """(?x)\\b(?<=[\\s()]|^)
			(abs|append|apply|assoc|butlast|c[ad]{1,2}r|c[ad]r-safe|consp?|copy-alist|copy-tree
			|dolist|funcall|last|length|listp?|load|make-list|mapc|mapcar|max|min|member|nbutlast
			|nconc|nreverse|nth|nthcdr|null|pop|prin[1ct]|push|quote|rassoc|reverse|rplac[ad]
			|safe-length|setcar|setcdr)
			(?=[\\s()]|$)\\b"""


	# :keywords
	keyword:
		name: "constant.keyword.emacs.lisp"
		match: "(:)[-\\w]+"
		captures:
			1: name: "punctuation.definition.keyword.emacs.lisp"


	# Lambda function
	lambda:
		name: "meta.lambda.expression.emacs.lisp"
		begin: "(\\()(lambda|function)\\s+"
		end:   "\\)"
		beginCaptures:
			1: name: "punctuation.section.expression.begin.emacs.lisp"
			2: name: "storage.type.lambda.function.emacs.lisp"
		endCaptures:
			0: name: "punctuation.section.expression.end.emacs.lisp"
		patterns: [include: "#defun-innards"]


	# Modeline
	modeline:
		name: "meta.modeline.emacs.lisp"
		match: "(-\\*-)(.*)(-\\*-)"
		captures:
			1: name: "punctuation.definition.modeline.begin.emacs.lisp"
			2: patterns: [include: "#modeline-innards"]
			3: name: "punctuation.definition.modeline.end.emacs.lisp"

	"modeline-innards":
		patterns: [{
			name: "meta.modeline.variable.emacs.lisp"
			match: "([^\\s:;]+)\\s*(:)\\s*([^;]*)"
			captures:
				1: name: "variable.assignment.modeline.emacs.lisp"
				2: name: "punctuation.separator.key-value.emacs.lisp"
				3: patterns: [include: "#modeline-innards"]
			}
			{name: "punctuation.terminator.statement.emacs.lisp", match: ";"}
			{name: "punctuation.separator.key-value.emacs.lisp",  match: ":"}
			{name: "string.other.modeline.emacs.lisp", match: "\\S+"}
		]




	# Numeric literals
	number:
		patterns: [{
			name: "constant.numeric.float.emacs.lisp"
			match: "(?<!\\w)-?\\d*\\.\\d+(?:[Ee][-+]?\\d+)?"
		},{
			name: "constant.numeric.integer.emacs.lisp"
			match: "(?<!\\w)-?\\d+(?:[Ee][-+]?\\d+)?"
		}]
		

	# "Operators" (as far as TextMate's classification is concerned)
	operators:
		patterns: [{
			
			# Control flow
			name: "keyword.control.$1.emacs.lisp"
			match: """(?x)(?<=[()]|^)
				(and|catch|cond|condition-case(?:-unless-debug)?|dotimes|eql?
				|equal|if|not|or|pcase|prog[12n]|throw|unless|unwind-protect
				|when|while)
				(?=[\\s()]|$)"""
		},{
			
			# Interactive function marker
			match: "(?<=\\(|\\s|^)(interactive)(?=\\s|\\(|\\))"
			name: "storage.modifier.interactive.function.emacs.lisp"
		},{
			
			# Mathematical operators
			name: "keyword.operator.numeric.emacs.lisp"
			match: "(?<=\\(|\\s|^)[-*+/](?=\\s|\\)|$)"
		},{
			
			# Comparison operators
			name: "keyword.operator.comparison.emacs.lisp"
			match: "(?<=\\(|\\s|^)[=<>]|[/<>]=(?=\\s|\\)|$)"
		}]


	# Argument-quoting
	quote:
		patterns: [{
			
			# 'value
			name: "string.quoted.other.emacs.lisp"
			match: "(')[-\\w]+"
			captures:
				1: name: "punctuation.definition.quote.emacs.lisp"
		}]

	
	# "Double-quoted" string
	string:
		name: "string.quoted.double.emacs.lisp"
		begin: '"'
		end:   '"'
		beginCaptures: 0: name: "punctuation.definition.string.begin.emacs.lisp"
		endCaptures:   0: name: "punctuation.definition.string.end.emacs.lisp"
		patterns: [
			match: '(\\\\).'
			name: "constant.character.escape.emacs.lisp"
			captures:
				1: name: "punctuation.escape.backslash.emacs.lisp"
		]
